<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Learning To Rank Library: Data manipulation</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://www.mathjax.org/mathjax/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Learning To Rank Library
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>About</span></a></li>
      <li><a href="_doc_contents.html"><span>Documentation</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="header">
  <div class="headertitle">
<div class="title">Data manipulation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#TutorialIntroduction">Introduction</a></li>
<li class="level1"><a href="#TutorialDataObject">Object</a><ul><li class="level2"><a href="#TutorialDataObjectFeatures">Features</a></li>
<li class="level2"><a href="#TutorialDataObjectLabels">Actual and predicted labels</a></li>
<li class="level2"><a href="#TutorialDataObjectCopying">Copying objects</a></li>
</ul>
</li>
<li class="level1"><a href="#TutorialDataObjectPair">ObjectPair</a></li>
<li class="level1"><a href="#TutorialDataObjectList">ObjectList</a></li>
<li class="level1"><a href="#TutorialDataPerObjectAccessor">PerObjectAccessor</a></li>
<li class="level1"><a href="#TutorialDataDataSet">DataSet</a><ul><li class="level2"><a href="#TutorialDataDataSetBasicOperations">Basic operations</a></li>
<li class="level2"><a href="#TutorialDataDataSetSavingAndLoading">Loading and saving into files</a></li>
<li class="level2"><a href="#TutorialDataDataSetFeatureInfo">Feature info</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h2><a class="anchor" id="TutorialIntroduction"></a>
Introduction</h2>
<p>There are <a href="http://en.wikipedia.org/wiki/Learning_to_rank#Approaches">three approaches</a> to learning to rank:</p>
<ul>
<li>Pointwise approach</li>
<li>Pairwise approach</li>
<li>Listwise approach</li>
</ul>
<p>The difference is in the type of used train data. In order to provide all approaches <a class="el" href="classltr_1_1_data_set.html">DataSet</a> in LTR has a template paramter <code>TElement</code>, which can be <a class="el" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">Object</a>, <a class="el" href="classltr_1_1_object_pair.html" title="The class stores a pair of two objects. The container for two objects, can be stored in DataSet...">ObjectPair</a> and <a class="el" href="classltr_1_1_object_list.html">ObjectList</a> for pointwise, pairwise and listwise approaches correspondingly.</p>
<h2><a class="anchor" id="TutorialDataObject"></a>
Object</h2>
<p><a class="el" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">Object</a> is the main class to operate with data. Any object contains features, actual and predicted labels. Every feature has index and double value.</p>
<h3><a class="anchor" id="TutorialDataObjectFeatures"></a>
Features</h3>
<p>Every <a class="el" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">Object</a> has several features with indexes 0, 1, 2... Every feature is a double value.</p>
<p>You can operate with features using this functions: </p>
<ul>
<li><a class="el" href="">featureCount() </a> - returns number of features </li>
<li><a class="el" href="classltr_1_1_object.html#ad63a366eb15a0f202578d408b5b4ebb5">features() </a> - returns vector of features </li>
<li><a class="el" href="classltr_1_1_object.html#a1d6226a913a20dac3902b5f59a945b75">operator[](int i)</a>, <a class="el" href="classltr_1_1_object.html#a3907e628402d0119b9c7f8c26ea64445">at(int i)</a> - access to the i'th feature of the object </li>
<li><a class="el" href="classltr_1_1_object.html#a031df6a2aee6d15b9f82446c7a296f7d">Object::operator&lt;&lt;(double value)</a> - adds new feature to the object</li>
</ul>
<table class="doxtable">
<tr>
<th>Example: Operating with features </th><th>Output:</th></tr>
<tr>
<td><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="object_8h.html">ltr/data/object.h</a>&quot;</span>

<span class="keyword">using</span> std::cout;
<span class="keyword">using</span> std::vector;
<span class="keyword">using</span> std::endl;
<span class="keyword">using</span> <a class="code" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">ltr::Object</a>;

<span class="keywordtype">int</span> <a class="code" href="generator_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {
  Object obj;
  obj &lt;&lt; 1.1 &lt;&lt; 45.3 &lt;&lt; 1e6;              <span class="comment">// Object contains now 3 features</span>
  cout &lt;&lt; <span class="stringliteral">&quot;obj = &quot;</span> &lt;&lt; obj &lt;&lt; endl;        <span class="comment">// You can print an object</span>

  cout &lt;&lt; <span class="stringliteral">&quot;obj.feature_count() = &quot;</span> 
           &lt;&lt; obj.feature_count() &lt;&lt; endl;     <span class="comment">// Method featureCount returns count of features in object</span>

  obj &lt;&lt; 2.4;                              <span class="comment">// You can add new features at any time.</span>
  cout &lt;&lt; <span class="stringliteral">&quot;feature was added&quot;</span> &lt;&lt; endl;

  cout &lt;&lt; <span class="stringliteral">&quot;obj.feature_count() = &quot;</span> 
           &lt;&lt; obj.feature_count() &lt;&lt; endl;     <span class="comment">// Returns 4</span>

  cout &lt;&lt; <span class="stringliteral">&quot;obj[0] = &quot;</span>  &lt;&lt; obj[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>          <span class="comment">// Two ways to get the feature value.</span>
       &lt;&lt; <span class="stringliteral">&quot;obj.at(1) = &quot;</span>  &lt;&lt; obj.at(1) &lt;&lt; endl;   <span class="comment">//</span>

  vector&lt;double&gt; new_features;
  new_features.push_back(1);
  new_features.push_back(5.0);
  new_features.push_back(2);

  obj.features() = new_features;  <span class="comment">// You can also set all objects features at once.</span>
  cout &lt;&lt; <span class="stringliteral">&quot;obj = &quot;</span> &lt;&lt; obj;

  <span class="keywordflow">return</span> 0;
}

</pre></div> </td><td><div class="fragment"><pre class="fragment">obj = [1.10, 45.30, 1000000.00]{0.00, 0.00}
obj.feature_count() = 3
feature was added
obj.feature_count() = 4
obj[0] = 1.1, obj.at(1) = 45.3
obj = [1.00, 5.00, 2.00]{0.00, 0.00}
</pre></div> </td></tr>
</table>
<h3><a class="anchor" id="TutorialDataObjectLabels"></a>
Actual and predicted labels</h3>
<p>Every object has an actual label and a predicted label. This labels are double values.</p>
<p>You can manage them, using this functions: </p>
<ul>
<li><a class="el" href="">setActualLabel(double label) </a> </li>
<li><a class="el" href="">setPredictedLabel(double label) </a> </li>
<li><a class="el" href="">actualLabel() </a> </li>
<li><a class="el" href="">predictedLabel() </a></li>
</ul>
<table class="doxtable">
<tr>
<th>Example: Operating with actual and predicted labels </th><th>Output:</th></tr>
<tr>
<td><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="object_8h.html">ltr/data/object.h</a>&quot;</span>

<span class="keyword">using</span> std::cout;
<span class="keyword">using</span> std::vector;
<span class="keyword">using</span> std::endl;
<span class="keyword">using</span> <a class="code" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">ltr::Object</a>;

<span class="keywordtype">int</span> <a class="code" href="generator_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {
  Object obj;
  obj.set_actual_label(23.65);
  obj.set_predicted_label(21.12);

  cout &lt;&lt; obj.actual_label() &lt;&lt; endl;
  cout &lt;&lt; obj.predicted_label() &lt;&lt; endl;
  cout &lt;&lt; obj;
  <span class="keywordflow">return</span> 0;
}

</pre></div> </td><td><div class="fragment"><pre class="fragment">23.65
21.12
[]{23.65, 21.12}
</pre></div> </td></tr>
</table>
<h3><a class="anchor" id="TutorialDataObjectCopying"></a>
Copying objects</h3>
<p>There are two ways to copy objects. </p>
<ul>
<li>Simple copy: it doesn't create real copy of the object. It copyes only links to features and metaInfo. <div class="fragment"><pre class="fragment"> Object b = a;                 <span class="comment">// This creates a simple copy.</span>
</pre></div> </li>
<li>Deep copy: creates real copy of the object. To use deep copy you should call <a class="el" href="classltr_1_1_object.html#a54c50845a2efd62c7b7ae51f8d9e2f2b">deepCopy()</a> <div class="fragment"><pre class="fragment"> Object b = a.deepCopy();      <span class="comment">// This creates a full copy.</span>
</pre></div></li>
</ul>
<table class="doxtable">
<tr>
<th>Example: Copying objects </th><th>Output:</th></tr>
<tr>
<td><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="object_8h.html">ltr/data/object.h</a>&quot;</span>

<span class="keyword">using</span> std::cout;
<span class="keyword">using</span> std::vector;
<span class="keyword">using</span> std::endl;
<span class="keyword">using</span> <a class="code" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">ltr::Object</a>;

<span class="keywordtype">int</span> <a class="code" href="generator_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {
  Object obj1, obj2;

  obj1 &lt;&lt; 2 &lt;&lt; 4 &lt;&lt; 6 &lt;&lt; 8;

  obj2 = obj1;                <span class="comment">// Simple copy</span>

  cout &lt;&lt; obj2[1] &lt;&lt; endl;
  obj1[1] = -1;               <span class="comment">// After changing value in obj1</span>
  cout &lt;&lt; obj2[1]             <span class="comment">// Value in obj2 changes too</span>
       &lt;&lt; endl &lt;&lt; endl;

  obj2 = obj1.deepCopy();

  cout &lt;&lt; obj2[1] &lt;&lt; endl;
  obj1[1] = 5;                <span class="comment">// Now nothing changes in obj2</span>
  cout &lt;&lt; obj2[1];            <span class="comment">// After changing obj1</span>

  <span class="keywordflow">return</span> 0;
}

</pre></div> </td><td><div class="fragment"><pre class="fragment">4
-1

-1
-1
</pre></div> </td></tr>
</table>
<h2><a class="anchor" id="TutorialDataObjectPair"></a>
ObjectPair</h2>
<p>Class to operate pairs of object. Every pair contains two objects: </p>
<ul>
<li><a class="el" href="classltr_1_1_object_pair.html#a5bc9d0318053b4a97ae09dba7f1484eb">ObjectPair::first</a>, <a class="el" href="classltr_1_1_object_pair.html#a16d1f72890a21590044b8a915f5793f0">ObjectPair::second</a></li>
</ul>
<table class="doxtable">
<tr>
<th>Example: Manipulating objects in pair </th><th>Output:</th></tr>
<tr>
<td><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="object__pair_8h.html">ltr/data/object_pair.h</a>&quot;</span>

<span class="keyword">using</span> std::cout;
<span class="keyword">using</span> std::vector;
<span class="keyword">using</span> std::endl;
<span class="keyword">using</span> <a class="code" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">ltr::Object</a>;
<span class="keyword">using</span> <a class="code" href="classltr_1_1_object_pair.html" title="The class stores a pair of two objects. The container for two objects, can be stored in DataSet...">ltr::ObjectPair</a>;

<span class="keywordtype">int</span> <a class="code" href="generator_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {
  ObjectPair pair;
  Object obj1, obj2;
  obj1 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4;
  obj2 &lt;&lt; 4 &lt;&lt; 6 &lt;&lt; 7 &lt;&lt; 8;
  pair.first = obj1;
  pair.second = obj2;

  cout &lt;&lt; <span class="stringliteral">&quot;pair = &quot;</span> &lt;&lt; pair &lt;&lt; endl;

  <span class="keywordflow">return</span> 0;
}

</pre></div> </td><td><div class="fragment"><pre class="fragment">pair = ([1.00, 2.00, 3.00, 4.00]{0.00, 0.00}, [4.00, 6.00, 7.00, 8.00]{0.00, 0.00})
</pre></div> </td></tr>
</table>
<h2><a class="anchor" id="TutorialDataObjectList"></a>
ObjectList</h2>
<p>Class to operate pairs of object. Every list contains several objects.</p>
<p>There are several ways to get object from a list. </p>
<ul>
<li><a class="el" href="">at(const size_t id) </a> </li>
<li><a class="el" href="">operator[](const size_t id) </a></li>
</ul>
<p>You can also add objects into list using operator&lt;&lt; or <a class="el" href="classltr_1_1_object_list.html#a92484286b47e88599df3467bad521296">add(Object) </a> method.<br/>
 List can be cleared by calling <a class="el" href="classltr_1_1_object_list.html#aa3e18d9e013370d3b00ddcca8200ec78">clear()</a> method.<br/>
 To find out, how many elements are there in the list, call the <a class="el" href="classltr_1_1_object_list.html#a4b1fcfadfe5de276876a03ac7e569dbe">size()</a> method.</p>
<h2><a class="anchor" id="TutorialDataPerObjectAccessor"></a>
PerObjectAccessor</h2>
<p><a class="el" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">Object</a>, <a class="el" href="classltr_1_1_object_pair.html" title="The class stores a pair of two objects. The container for two objects, can be stored in DataSet...">ObjectPair</a> and <a class="el" href="classltr_1_1_object_list.html">ObjectList</a> are currently main data types used in LTR. If you want to write a code handling all of them <a class="el" href="classltr_1_1_per_object_accessor.html">PerObjectAccessor</a> is what you need. It allows you to access an individual <a class="el" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">Object</a> in all this containers by index. In the example below function for printing actual labels is implemented.</p>
<table class="doxtable">
<tr>
<th>Example: Working with PerObjectAccessor </th><th>Output:</th></tr>
<tr>
<td><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="preprocessor">#include &quot;<a class="code" href="object__list_8h.html">ltr/data/object_list.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="per__object__accessor_8h.html">ltr/data/per_object_accessor.h</a>&quot;</span>

<span class="keyword">using</span> std::cout;
<span class="keyword">using</span> std::vector;
<span class="keyword">using</span> std::endl;
<span class="keyword">using</span> <a class="code" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">ltr::Object</a>;
<span class="keyword">using</span> <a class="code" href="classltr_1_1_object_list.html">ltr::ObjectList</a>;
<span class="keyword">using</span> <a class="code" href="classltr_1_1_per_object_accessor.html">ltr::PerObjectAccessor</a>;

<span class="keyword">template</span> &lt;<span class="keyword">class</span> TElement&gt;
<span class="keywordtype">void</span> PrintActualLabels(<span class="keyword">const</span> TElement &amp;element) {
  PerObjectAccessor&lt;const TElement&gt; per_object_accessor(&amp;element);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> object_index = 0;
       object_index &lt; per_object_accessor.object_count(); ++object_index) {
       cout &lt;&lt; <span class="stringliteral">&quot;actual[&quot;</span> &lt;&lt; object_index &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span>
            &lt;&lt; per_object_accessor.object(object_index).actual_label() &lt;&lt; endl;
  }
}

<span class="keywordtype">int</span> <a class="code" href="generator_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {
  ObjectList list;
  Object obj1, obj2, obj3, obj4;
  obj1.set_actual_label(10);
  obj2.set_actual_label(20);
  obj3.set_actual_label(30);
  obj4.set_actual_label(40);
  list &lt;&lt; obj1 &lt;&lt; obj2 &lt;&lt; obj3 &lt;&lt; obj4;

  PrintActualLabels(list);
  <span class="keywordflow">return</span> 0;
}

</pre></div> </td><td><div class="fragment"><pre class="fragment">actual[0] = 10
actual[1] = 20
actual[2] = 30
actual[3] = 40
</pre></div> </td></tr>
</table>
<h2><a class="anchor" id="TutorialDataDataSet"></a>
DataSet</h2>
<p><a class="el" href="classltr_1_1_data_set.html">DataSet</a> is a class to operate with sets of data. It can contain <a class="el" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">Object</a>, <a class="el" href="classltr_1_1_object_pair.html" title="The class stores a pair of two objects. The container for two objects, can be stored in DataSet...">ObjectPair</a> or <a class="el" href="classltr_1_1_object_list.html">ObjectList</a> as elements.<br/>
Every elment can also has a double weight, default weight is 1. </p>
<div class="fragment"><pre class="fragment">DataSet&lt;Object&gt;     data1;   <span class="comment">// This data set contains objects</span>
DataSet&lt;ObjectPair&gt; data2;   <span class="comment">// This data set contains pair</span>
DataSet&lt;ObjectList&gt; data3;   <span class="comment">// This data set contains lists</span>
</pre></div><p>Ltr defines typedefs for this three types of <a class="el" href="classltr_1_1_data_set.html">DataSet</a>: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> DataSet&lt;Object&gt;     PointwiseDataSet;
<span class="keyword">typedef</span> DataSet&lt;ObjectPair&gt; PairwiseDataSet;
<span class="keyword">typedef</span> DataSet&lt;ObjectList&gt; ListwiseDataSet;
</pre></div><h3><a class="anchor" id="TutorialDataDataSetBasicOperations"></a>
Basic operations</h3>
<p>Function for basic operations: </p>
<ul>
<li><a class="el" href="classltr_1_1_data_set.html#a41227a53bcb0914f9ff3558987c39bce">DataSet::size()</a> - returns number of elements in <a class="el" href="classltr_1_1_data_set.html">DataSet</a> </li>
<li><a class="el" href="classltr_1_1_data_set.html#aac34ecb57f749c0c4659d903a7eeb0cc">DataSet::clear()</a> - cleares <a class="el" href="classltr_1_1_data_set.html">DataSet</a></li>
</ul>
<ul>
<li><a class="el" href="classltr_1_1_data_set.html#addb95d8ff26575686ddc3d0f845b6d32">DataSet::add(const TElement&amp;)</a> - adds element to <a class="el" href="classltr_1_1_data_set.html">DataSet</a> </li>
<li><a class="el" href="classltr_1_1_data_set.html#a21d150613486a6473d4444add71f3255">DataSet::operator&lt;&lt;(const TElement&amp;)</a> - adds element to <a class="el" href="classltr_1_1_data_set.html">DataSet</a> </li>
<li><a class="el" href="classltr_1_1_data_set.html#a01a3fe8f84d88f1d8c7cc36f38a93479">DataSet::add(const TElement&amp;, double weight)</a> - adds element with weight to <a class="el" href="classltr_1_1_data_set.html">DataSet</a> </li>
<li><a class="el" href="classltr_1_1_data_set.html#ac64be8f8531671d838570ed2786d6e86">Dataset::setWeight(size_t element_idx, double weight) </a> - sets weight of element with index idx</li>
</ul>
<ul>
<li><a class="el" href="classltr_1_1_data_set.html#a1cf3b56490859e13a53cecb03d2ef616">DataSet::at(size_t idx) </a> - returns element with index idx </li>
<li><a class="el" href="classltr_1_1_data_set.html#ac1b9e1fdd411603be60803c94c9e8a5a">DataSet::operator[](size_t idx) </a> - returns element with index idx </li>
<li><a class="el" href="classltr_1_1_data_set.html#a7f96bba4c1b97fa93f8447282e94bfd2">DataSet::getWeight(size_t idx) </a> - returns the weight of element with index idx </li>
<li><a class="el" href="classltr_1_1_data_set.html#a80decf67497c4a953ba9c32400a6a734">DataSet::erase(size_t i) </a> - removes the element from the <a class="el" href="classltr_1_1_data_set.html">DataSet</a>.</li>
</ul>
<ul>
<li><a class="el" href="classltr_1_1_data_set.html#af2868844fcf27979623e388ad9785a3a">DataSet::deepCopy()</a> - creates a full copy of <a class="el" href="classltr_1_1_data_set.html">DataSet</a></li>
</ul>
<table class="doxtable">
<tr>
<th>Example: Basic DataSet operations </th><th>Output:</th></tr>
<tr>
<td><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="data__set_8h.html">ltr/data/data_set.h</a>&quot;</span>

<span class="keyword">using</span> std::cout;
<span class="keyword">using</span> std::vector;
<span class="keyword">using</span> std::endl;
<span class="keyword">using</span> <a class="code" href="classltr_1_1_object.html" title="Base class for storing information in a Dataset. An object consist of feature vector and meta informa...">ltr::Object</a>;
<span class="keyword">using</span> <a class="code" href="classltr_1_1_data_set.html">ltr::DataSet</a>;

<span class="keywordtype">int</span> <a class="code" href="generator_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {
  DataSet&lt;Object&gt; data;
  Object obj1, obj2, obj3, obj4;

  obj1 &lt;&lt; 12.0 &lt;&lt; 54.11;
  obj2 &lt;&lt; 1.30 &lt;&lt; 4.15;
  obj3 &lt;&lt; 10.30 &lt;&lt; 14.3;
  obj4 &lt;&lt; 19.0 &lt;&lt; 47.5;

  data &lt;&lt; obj1 &lt;&lt; obj2;
  data.add(obj3, 2.12);
  data.add(obj4, 1.21);

  cout &lt;&lt; <span class="stringliteral">&quot;data = &quot;</span> &lt;&lt; endl &lt;&lt; data &lt;&lt; endl; <span class="comment">// You can print DataSet</span>

  cout &lt;&lt; <span class="stringliteral">&quot;data.size() = &quot;</span> &lt;&lt; data.size() &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;data[0] = &quot;</span> &lt;&lt; data[0] &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;data.at(1) = &quot;</span> &lt;&lt; data.at(1) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;data.getWeight(2) = &quot;</span> &lt;&lt; data.getWeight(2) &lt;&lt; endl;

  data.setWeight(2, 0.01);
  cout &lt;&lt; <span class="stringliteral">&quot;data.getWeight(2) = &quot;</span> &lt;&lt; data.getWeight(2) &lt;&lt; endl;

  data.erase(1);
  cout &lt;&lt; <span class="stringliteral">&quot;called data.erase(1)&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;data[1] = &quot;</span> &lt;&lt; data[1] &lt;&lt; endl;

  data.clear();
  cout &lt;&lt; <span class="stringliteral">&quot;called data.clear()&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;data.size() = &quot;</span> &lt;&lt; data.size() &lt;&lt; endl;
  <span class="keywordflow">return</span> 0;
}

</pre></div> </td><td><div class="fragment"><pre class="fragment">data = 
[12.00, 54.11]{0.00, 0.00}
[1.30, 4.15]{0.00, 0.00}
[10.30, 14.30]{0.00, 0.00}
[19.00, 47.50]{0.00, 0.00}

data.size() = 4
data[0] = [12.00, 54.11]{0.00, 0.00}
data.at(1) = [1.30, 4.15]{0.00, 0.00}
data.getWeight(2) = 2.12
data.getWeight(2) = 0.01
called data.erase(1)
data[1] = [10.30, 14.30]{0.00, 0.00}
called data.clear()
data.size() = 0
</pre></div> </td></tr>
</table>
<h3><a class="anchor" id="TutorialDataDataSetSavingAndLoading"></a>
Loading and saving into files</h3>
<p>Main thing, you can do with <a class="el" href="classltr_1_1_data_set.html">DataSet</a>, is to load it from file or save it into file.</p>
<p>List of supported formats:</p>
<table class="doxtable">
<tr>
<th>Format: </th><th>Load </th><th>Save </th><th>Description:</th></tr>
<tr>
<td>svmlight </td><td>+ </td><td>+ </td><td><a href="http://svmlight.joachims.org/">http://svmlight.joachims.org/</a> </td></tr>
<tr>
<td>yandex </td><td>+ </td><td>+ </td><td><a href="http://imat2009.yandex.ru/en/datasets">http://imat2009.yandex.ru/en/datasets</a> </td></tr>
<tr>
<td>arff </td><td>+ </td><td>- </td><td><a href="http://weka.wikispaces.com/ARFF+%28book+version%29">http://weka.wikispaces.com/ARFF+%28book+version%29</a> </td></tr>
</table>
<p>Function for loading <a class="el" href="classltr_1_1_data_set.html">DataSet</a> from file: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">class</span> TElement&gt;
DataSet&lt;TElement&gt; ltr::io_utility::loadDataSet(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; filename, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; format);
</pre></div><ul>
<li><code>TElement</code> - type of elements in <a class="el" href="classltr_1_1_data_set.html">DataSet</a>. </li>
<li><code>filename</code> - name of file with data. </li>
<li><code>format</code> - format of data in the file. It can be "yandex", "svmlight" or "Arff"</li>
</ul>
<dl class="section note"><dt>Note:</dt><dd><ul>
<li>Missed features will be changed by ltr::utility::NaN</li>
<li>String (nominal) features will be changed by hash of the string value</li>
<li>Use <a class="el" href="classltr_1_1_feature_info.html#a566d68f92e542ffa489c2fa0b7aeb151">FeatureInfo::getFeatureValues</a> (see the next section) to restore the string value of a nominal feature</li>
</ul>
</dd></dl>
<p>Function for saving <a class="el" href="classltr_1_1_data_set.html">DataSet</a> into file. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">class</span> TElement&gt;
<span class="keywordtype">void</span> ltr::io_utility::saveDataSet(<span class="keyword">const</span> DataSet&lt;TElement&gt;&amp; data,
                                  <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; filename,
                                  <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; format);
</pre></div><ul>
<li><code>data</code> - data to save. </li>
<li><code>filename</code> - name of file to save data in </li>
<li><code>format</code> - format to save data. Can be "smv-lite" or "yandex"</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="io__utility_8h.html">ltr/data/utility/io_utility.h</a>&quot;</span>

<span class="keyword">using</span> ltr::io_utility::loadDataSet;
<span class="keyword">using</span> ltr::io_utility::saveDataSet;

<span class="keyword">using</span> <a class="code" href="classltr_1_1_data_set.html">ltr::DataSet</a>;

<span class="keywordtype">int</span> <a class="code" href="generator_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {
  DataSet&lt;Object&gt; = loadDataSet&lt;Object&gt;(<span class="stringliteral">&quot;test_file&quot;</span>, <span class="stringliteral">&quot;svmlight&quot;</span>);
  <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" id="TutorialDataDataSetFeatureInfo"></a>
Feature info</h3>
<p><a class="el" href="classltr_1_1_feature_info.html" title="Class is storing info about all features.">FeatureInfo</a> initially appeared to support arff format and containes information about types (e.g. <code>NOMINAL</code>, <code>NUMERIC</code>, <code>BOOLEAN</code>) and possible values of features.</p>
<p>One can access <a class="el" href="classltr_1_1_feature_info.html" title="Class is storing info about all features.">FeatureInfo</a> of <a class="el" href="classltr_1_1_data_set.html">DataSet</a> using <a class="el" href="classltr_1_1_data_set.html#a6b173f125c05565128da0ab8486b2e5c">DataSet::feature_info()</a>.</p>
<p><a class="el" href="classltr_1_1_feature_info.html" title="Class is storing info about all features.">FeatureInfo</a> public functions:</p>
<ul>
<li><a class="el" href="classltr_1_1_feature_info.html#ac401b4c48ca120c5c2ebba7007602a37">FeatureInfo::feature_count()</a> - return count of features</li>
<li><a class="el" href="classltr_1_1_feature_info.html#ada9d073392d626e6ae45663dd0f5c4f6">FeatureInfo::resize</a> - change number of features</li>
<li><a class="el" href="classltr_1_1_feature_info.html#ab1983d9f60172d03f4152d2aa129e1c8">FeatureInfo::addFeature</a> - add info about one feature</li>
<li><a class="el" href="classltr_1_1_feature_info.html#a57d3eeea58cb56cd73b41b500ca7e50e">FeatureInfo::getFeatureType</a> - return feature type: <code>NOMINAL</code>, <code>NUMERIC</code> or <code>BOOLEAN</code> </li>
<li><a class="el" href="classltr_1_1_feature_info.html#a566d68f92e542ffa489c2fa0b7aeb151">FeatureInfo::getFeatureValues</a> - return map from numeric to string values for <code>NOMINAL</code> features </li>
</ul>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 21 2013 17:48:33 for Learning To Rank Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
